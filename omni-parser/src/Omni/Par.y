-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Omni.Par
  ( happyError
  , myLexer
  , pModule
  ) where

import Prelude

import qualified Omni.Abs
import Omni.Lex
import qualified Data.Text

}

%name pModule_internal Module
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  'd'    { PT _ (TS _ 1) }
  's'    { PT _ (TS _ 2) }
  'st'   { PT _ (TS _ 3) }
  'teed' { PT _ (TS _ 4) }

%%


Module :: { (Omni.Abs.BNFC'Position, Omni.Abs.Module) }
Module : ListTopDef { (fst $1, Omni.Abs.Module (fst $1) (snd $1)) }

TopDef :: { (Omni.Abs.BNFC'Position, Omni.Abs.TopDef) }
TopDef
  : 'teed' 'd' 's' 'st' { (uncurry Omni.Abs.BNFC'Position (tokenLineCol $1), Omni.Abs.FnDef (uncurry Omni.Abs.BNFC'Position (tokenLineCol $1))) }

ListTopDef :: { (Omni.Abs.BNFC'Position, [Omni.Abs.TopDef]) }
ListTopDef
  : TopDef { (fst $1, (:[]) (snd $1)) }
  | TopDef ListTopDef { (fst $1, (:) (snd $1) (snd $2)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

-- Entrypoints

pModule :: [Token] -> Err Omni.Abs.Module
pModule = fmap snd . pModule_internal
}

