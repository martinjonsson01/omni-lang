-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Omni.Par
  ( happyError
  , myLexer
  , pModule
  ) where

import Prelude

import qualified Omni.Abs
import Omni.Lex
import qualified Data.Text

}

%name pModule_internal Module
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  'module' { PT _ _ (TS _ 1) }
  'test'   { PT _ _ (TS _ 2) }
  L_Ident  { PT _ _ (TV _)   }

%%

Ident :: { (Omni.Abs.BNFC'Position, Omni.Abs.Ident) }
Ident  : L_Ident { (uncurry Omni.Abs.BNFC'Position (tokenSpan $1), Omni.Abs.Ident (tokenText $1)) }

Module :: { (Omni.Abs.BNFC'Position, Omni.Abs.Module) }
Module
  : 'module' Ident ListTopDef { (Omni.Abs.spanBNFC'Position (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)) (fst $3), Omni.Abs.Module (Omni.Abs.spanBNFC'Position (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)) (fst $3)) (snd $2) (snd $3)) }

TopDef :: { (Omni.Abs.BNFC'Position, Omni.Abs.TopDef) }
TopDef
  : 'test' { (Omni.Abs.spanBNFC'Position (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)) (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)), Omni.Abs.FnDef (Omni.Abs.spanBNFC'Position (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)) (uncurry Omni.Abs.BNFC'Position (tokenSpan $1)))) }

ListTopDef :: { (Omni.Abs.BNFC'Position, [Omni.Abs.TopDef]) }
ListTopDef
  : TopDef { (Omni.Abs.spanBNFC'Position (fst $1) (fst $1), (:[]) (snd $1)) }
  | TopDef ListTopDef { (Omni.Abs.spanBNFC'Position (fst $1) (fst $2), (:) (snd $1) (snd $2)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

-- Entrypoints

pModule :: [Token] -> Err Omni.Abs.Module
pModule = fmap snd . pModule_internal
}

